// NIPutils
// v2
// utility Functions that are only really useful for NIPcode

// functions for dealing with Neuralynx

Function ADBitVoltsFromCheetahheader(headerwave)
	WAVE/t headerwave
	
	variable ADbitvolts
	// Files generated by Cheetah 5.5.1 lack a "-FileVersion" line in their headers
	FindValue/TEXT="FileVersion" headerwave
	if (V_value < 0)
		// header is 5.5.1 format	
		ADBitVolts =  str2num (ReplaceString("-ADBitVolts",headerwave[14], "")) 
	else
		// if header is 5.6.0 format
		ADBitVolts =  str2num (ReplaceString("-ADBitVolts",headerwave[15], "")) 
	endif
	
	return ADbitvolts
end

// different strategy - maybe more robust
Function ADBitVoltsFromCheetahheader2 (headerwave)
	wave/t headerwave
	
	variable ADbitvolts
	
	findvalue/TEXT="-ADBitVolts" headerwave
	if (V_value < 0)
		printf "yipes!  No -ADBitVolts string found in header %s\r", nameofwave(headerwave)
	else
		return (str2num(replacestring("-ADBitVolts",headerwave[V_value], "")))
	endif
	
	
end	

//delete sections from theTarget bounded by point pairs given in nameofdeletionswave
Function deletefrompointlistALL (deletionswave)				
	WAVE deletionswave

	string wavenames = wavelist("*",";","")
	variable numwaves = itemsinlist(wavenames),i
	
	for (i=0; i < numwaves; i += 1)

		WAVE nextwave = $stringfromlist(i,wavenames)
		deletefrompointlist(nextwave, deletionswave)

	endfor
	
end

// delete sections from theTarget bounded by point pairs given in nameofdeletionswave
// value of -1 in second column means find end and delete to end
Function deletefrompointlist (theTarget, deletionswave)				
	WAVE theTarget, deletionswave

	variable numdeletions = DimSize(deletionswave, 0),i,pointstodelete
	
	for (i=0; i < numdeletions; i += 1)
		
		if (deletionswave[i][1] == -1)
			pointstodelete = (numpnts(theTarget)-deletionswave[i][0])
		else
			pointstodelete = deletionswave[i][1] - deletionswave[i][0] + 1
		endif	
		
		deletepoints deletionswave[i][0], pointstodelete, theTarget
		
		printf "deleted points %d to %d from %s\r", deletionswave[i][0], deletionswave[i][1], nameofwave(theTarget)

	endfor
	
end

Function testandaveragematches (matchstring)
	string matchstring
	
		string somewaves = Wavelist("*"+matchstring+"*",";","")
		variable numwaves =  itemsinlist(somewaves),i
		
		printf "computing average for%d waves: %s\r", numwaves,somewaves
		WAVE firstwave = $(stringfromlist(0,somewaves))
		//duplicate/o firstwave AVG
		printf "%s\r",stringfromlist(0,somewaves)
		variable length = numpnts(firstwave)
		
		// build in a couple of tests here
		if (numwaves != 16)
			printf "WARNING: number of waves is not 16\r"
		endif
	
		for (i=1; i < numwaves; i += 1)
			printf "...+ %s\r", stringfromlist(i,somewaves)
			WAVE nextwave = $(stringfromlist(i,somewaves))
			if (numpnts(nextwave) != length)
				printf "NOTE\r\r\rlength of %s does not match length of %s\r", nameofwave(nextwave), nameofwave(firstwave)
			endif
		endfor	

		fWaveAverage_smallNbigwaves(somewaves, "", 0, 0, "AVG", "")
		
		WAVE AVG
		
		// 122215 GC
		// AVG comes out of this function as 64-bit; redimension down to 32-bit to save space
		redimension/S AVG
		
		noteKWV (AVG,"AVGof",somewaves,0)

end

// NOTE: Average wave is created as an FP64!
Function fWaveAverage_smallNbigwaves(ListOfWaves, ListOfXWaves, ErrorType, ErrorInterval, AveName, ErrorName)
	String ListOfWaves		// Y waves
	String ListOfXWaves		// X waves list
	Variable ErrorType		// 0 = none; 1 = S.D.; 2 = Conf Int; 3 = Standard Error
	Variable ErrorInterval	// if ErrorType == 1, # of S.D.'s; ErrorType == 2, Conf. Interval
	String AveName, ErrorName
	
	Variable numWaves = ItemsInList(ListOfWaves)
	if (numWaves < 2 )
		DoAlert 0, "Need at least two waves to compute an average!"
		return -1
	endif
		
	if (numWaves > 256)
		DoAlert 0, "This function is specialized for a small number (< 256) of very large waves.  Too many waves here!"
		return -1
	endif		
		
	if ( ErrorType == 2)
		if ( (ErrorInterval>100) || (ErrorInterval < 0) )
			DoAlert 0, "Confidence interval must be between 0 and 100"
			return -1
		endif
		ErrorInterval /= 100
	endif
	
	// check the input waves, and choose an appropriate algorithm
	Variable maxLength = 0
	Variable differentLengths= 0
	Variable differentXRanges= 0
	Variable thisXMin, thisXMax, thisDeltax
	Variable minXmin, maxXmax, minDeltax
	Variable numXWaves=0
	String firstXWavePath = StringFromList(0,ListOfXWaves)
	Variable XWavesAreSame=1	// assume they are until proven differently. Irrelevant if	numXWaves!=numWaves
	Variable i
	Make/O/N=(numWaves,2)/FREE xRange	// [i][0] is xMin, [i][1] is xMax

	for (i = 0; i < numWaves; i += 1)
		String theWaveName=StringFromList(i,ListOfWaves)
		Wave/Z w=$theWaveName
		if (!WaveExists(w))
			DoAlert 0, "A wave in the list of waves ("+theWaveName+") cannot be found."
			return -1
		endif
		Variable thisLength= numpnts(w)
		String theXWavePath=StringFromList(i,ListOfXWaves)
		Wave/Z theXWave= $theXWavePath
		if( WaveExists(theXWave) )
			Variable isMonotonicX= MonotonicCheck(theXWave,thisDeltax)	// thisDeltax is set to min difference in the x wave
			if( !isMonotonicX )
				DoAlert 0, theXWavePath+" is not sorted (or has duplicate x values) and cannot be used to compute the average. You should sort both "+theXWavePath+" and "+theWaveName+"."
				return -1
			endif
			WaveStats/Q/M=0 theXWave
			thisXMin= V_Min
			thisXMax= V_Max
			numXWaves += 1
			if( CmpStr(theXWavePath,firstXWavePath) != 0 )	//comparing full paths, not wave values
				XWavesAreSame=0
			endif
		else
			thisDeltax= deltax(w)
			thisXMin= leftx(w)
			thisXMax= rightx(w)-thisDeltax	// SetScale/I values.
			XWavesAreSame=0	// at least 1 y wave has no x wave
		endif
		xRange[i][0]= thisXMin
		xRange[i][1]= thisXMax
		if( i > 0 )
			if( thisLength != maxLength )
				differentLengths= 1
			endif
			if( (thisXMin != minXmin) || (thisXMax != maxXmax) )
				differentXRanges= 1	// this also includes the case where identical ranges but one or more is swapped
			endif
			if( i == 1 )
				// handle case where first wave's x range is swapped.
				if( minXmin > maxXmax )	// swapped X range (X values decrease with increasing point number)
					Variable tmp= minXmin
					minXmin= maxXmax
					maxXmax= tmp
				endif
			endif
			if( thisXMin > thisXMax )	// swapped X range (X values decrease with increasing point number)
				tmp= thisXMin
				thisXMin= thisXMax
				thisXMax= tmp
			endif
			// accumulate x ranges
			minXmin= min(minXmin, thisXMin)
			maxXmax= max(maxXmax, thisXMax)
			// find smallest deltax
			thisDeltax= abs(thisDeltax)
			if( thisDeltax > 0 && (thisDeltax < minDeltax) )
				minDeltax= thisDeltax
			endif
		else
			minXmin= thisXMin
			maxXmax= thisXMax
			minDeltax= abs(thisDeltax)
			if( minDeltax == 0 )
				thisDeltax= inf
			endif
		endif
		maxLength = max(maxLength, thisLength)
	endfor
	
	Variable doPointForPoint
	if( numXWaves && !XWavesAreSame )
		doPointForPoint= 0
	else
		doPointForPoint = (!differentXRanges && !differentLengths) || numtype(minDeltaX) != 0 || minDeltaX == 0
	endif

	if( doPointForPoint )
		Make/N=(maxLength)/D/O $AveName
		Wave/Z AveW=$AveName
		Wave w=$StringFromList(0,ListOfWaves)
		CopyScales/P w, AveW
		AveW = 0
		
		// this is a change from the WM function
		// TempNwave is an 8-bit integer wave (make/b)
		Make/O/FREE/b/n=(numpnts(AveW)) TempNWave
		TempNWave = 0
		
		i = 0
		Variable j, npnts
		for (i = 0; i < numWaves; i += 1)
			WAVE w=$StringFromList(i,ListOfWaves)
			npnts = numpnts(w)
			for (j = 0; j < npnts; j += 1)
				if (numtype(w[j]) == 0)
					AveW[j] += w[j]
					TempNWave[j] += 1
				endif
			endfor
		endfor
		
		AveW /= TempNWave
		
		if (ErrorType)
			Duplicate/O AveW, $ErrorName
			Wave/Z SDW=$ErrorName
			SDW = 0
			i=0
			for (i = 0; i < numWaves; i += 1)
				WAVE w = $StringFromList(i,ListOfWaves)
				npnts = numpnts(w)
				for (j = 0; j < npnts; j += 1)
					if (numtype(w[j]) == 0)
						SDW[j] += (w[j]-AveW[j])^2
					endif
				endfor
			endfor
			SDW /= (TempNWave-1)
			SDW = sqrt(SDW)			// SDW now contains s.d. of the data for each point
			if (ErrorType > 1)
				SDW /= sqrt(TempNWave)	// SDW now contains standard error of mean for each point
				if (ErrorType == 2)
					SDW *= StudentT(ErrorInterval, TempNWave-1) // CLevel confidence interval width in each point
				endif
			else
				SDW *= ErrorInterval
			endif
		endif
	else
		// can't do point-for-point because of different point range or scaling or there are multiple X waves
		Variable firstAvePoint,lastAvePoint,point,xVal,yVal
		
		Variable newLength= 1 + round(abs(maxXmax - minXmin) / minDeltaX)
		maxLength= min(maxLength*4,newLength)	// avoid the case where one very small deltaX in an XY pair causes a huge wave to be created.
	
		Make/N=(maxLength)/D/O $AveName
		Wave/Z AveW=$AveName
		AveW= 0
		Wave w=$StringFromList(0,ListOfWaves)	
		CopyScales w, AveW // just to get the data and x units
		SetScale/I x, minXmin, maxXmax, AveW	// set X scaling to all-encompassing range
		
		// this is a change from the WM function
		// TempNwave is an 8-bit integer wave (make/b)
		Make/O/N=(maxLength)/B/FREE TempNWave= 0
	
		for (i = 0; i < numWaves; i += 1)
			thisXMin= xRange[i][0]
			thisXMax= xRange[i][1]
			if( thisXMin > thisXMax )	// swapped X range (X values decrease with increasing point number)
				tmp= thisXMin
				thisXMin= thisXMax
				thisXMax= tmp
			endif
			firstAvePoint= ceil(x2pnt(AveW,thisXMin))	// truncate the partial point numbers...
			lastAvePoint= floor(x2pnt(AveW,thisXMax))	// ... by indenting slightly
			WAVE wy=$StringFromList(i,ListOfWaves)
			Wave/Z wx= $StringFromList(i,ListOfXWaves)
			for (point = firstAvePoint; point <= lastAvePoint; point += 1)
				xVal= pnt2x(AveW, point)
				if( WaveExists(wx) )
					yVal= interp(xVal, wx, wy)
				else
					yVal= wy(xVal)
				endif
				if (numtype(yVal) == 0)
					AveW[point] += yVal
					TempNWave[point] += 1
				endif
			endfor
		endfor
		
		//  points with no values added are set to NaN here:
		MultiThread AveW= (TempNWave[p] == 0) ? NaN : AveW[p] / TempNWave[p]
		
		if (ErrorType)
			Duplicate/O AveW, $ErrorName
			Wave/Z SDW=$ErrorName
			SDW = 0

			for (i = 0; i < numWaves; i += 1)
				thisXMin= xRange[i][0]
				thisXMax= xRange[i][1]
				if( thisXMin > thisXMax )	// swapped X range (X values decrease with increasing point number)
					tmp= thisXMin
					thisXMin= thisXMax
					thisXMax= tmp
				endif
				firstAvePoint= ceil(x2pnt(AveW,thisXMin))	// truncate the partial point numbers...
				lastAvePoint= floor(x2pnt(AveW,thisXMax))	// ... by indenting slightly
				WAVE wy=$StringFromList(i,ListOfWaves)
				Wave/Z wx= $StringFromList(i,ListOfXWaves)
				for (point = firstAvePoint; point <= lastAvePoint; point += 1)
					xVal= pnt2x(AveW, point)
					if( WaveExists(wx) )
						yVal= interp(xVal, wx, wy)
					else
						yVal= wy(xVal)
					endif
					if (numtype(yVal) == 0)
						SDW[point] += (yVal-AveW[point]) * (yVal-AveW[point])
					endif
				endfor
			endfor
			MultiThread SDW= (TempNWave[p] <= 1) ? NaN : sqrt(SDW[p] / (TempNWave[p] -1))	// SDW now contains s.d. of the data for each point
			if (ErrorType > 1)
				MultiThread SDW= (TempNWave[p] == 0) ? NaN : SDW[p] / sqrt(TempNWave[p])	// SDW now contains standard error of mean for each point
				if (ErrorType == 2)
					MultiThread SDW = (TempNWave[p] <= 1) ? NaN : SDW[p] * StudentT(ErrorInterval, TempNWave[p]-1) // Confidence Level confidence interval width in each point
				endif
			else
				MultiThread SDW = SDW[p] * ErrorInterval	// ???
			endif
		endif
		
	endif
	return doPointForPoint
End
Function MonotonicCheck(wx,smallestXIncrement)
	Wave wx
	Variable &smallestXIncrement	// output

	Variable isMonotonic=0
	
	Duplicate/O/Free wx, diff
	Differentiate/DIM=0/EP=0/METH=1/P diff 
	WaveStats/Q/M=0 diff
	isMonotonic= (V_min > 0) == (V_max > 0)

	diff= abs(diff[p])
	WaveStats/Q/M=0 diff
	smallestXIncrement= V_Min
	
	return isMonotonic && smallestXIncrement != 0 
End


// startdate is MMDDYY string
// datestring is in the Neuralynx format: YYYY-MM-DD_HH-MM-SS

// convert both dates to year, month, day
// use date2secs to find number of seconds to a reference time for each
// find difference, convert it to days

Function daysbetween (startdate, datestring)
	string startdate, datestring
	
	variable startdate_secs = date2secs(2000+str2num(startdate[4,5]),str2num(startdate[0,1]),str2num(startdate[2,3]))
	
	// first convert Neuralynx date/time string into a 6 digit MMDDYY
	// break it into date and time at the "_"
	variable underscorepos = strsearch(datestring,"_",0)
	
	string datepart = datestring[0,underscorepos-1]
	string timepart = datestring[underscorepos+1, strlen(datestring)-1]
	
	variable datestring_secs = date2secs(str2num(datepart[0,3]),str2num(datepart[5,6]),str2num(datepart[8,9]))	
	
	variable difference_secs = datestring_secs - startdate_secs
	variable difference_days = difference_secs / (60*60*24)
	
	return difference_days
	
end


// run from inside data_records folder
Function float2int(channelwave)
	WAVE channelwave
	
	// Find channelheader
	WAVE/t channelheader = $("root:headers_file:"+nameofwave(channelwave))
	
	
	variable ADbitvolts = ADBitVoltsFromCheetahHeader(channelheader)
	
	
	// divide by ADbitvolts
	channelwave /= ADbitvolts
	
	redimension/W channelwave
	
	
end


Function RTErrorCheck (marker)
	string marker

	variable err = GetRTError(0)
	if (err != 0)
		String message = geterrmessage(err)
		printf "Aborting due to Error at %s: %s\r", marker, message
		abort
		err = GetRTError(1)
		printf "cleared error state; continuing execution.\r"
	endif

end

Function SDlookup (SDs, channelnumber,deletestring)
	WAVE SDs
	variable channelnumber
	string deletestring	
							
	// split for lookup
	make/O/n=(DimSize(SDs, 0)) SDlist = SDs[p][0]
	make/O/n=(DimSize(SDs, 0)) channelnumberlist = SDs[p][1]
														
	// lookup SD for this channel
	FindValue/T=0.1/V=(channelnumber) channelnumberlist
	Variable SD_thischannel = SDlist[V_Value]

	killwaves/z SDlist, channelnumberlist
	
	return SD_thischannel
end

// replace channel number with XXX in nametemplate
Function quickgroupSD (nametemplate)
	string nametemplate
		
	string matchstring = UpToWhatever (nametemplate,"XXX")
		
	string matchingwavenames = wavelist ("*"+matchstring+"*", ";","")
	variable nummatches = itemsinlist(matchingwavenames),i
	make/n=(nummatches) SDs
	print matchingwavenames
	
	for (i=0; i < nummatches; i +=1)
		WAVE nextwave = $(replacestring( "XXX",nametemplate, num2str(i+1)))
		Wavestats/q nextwave
		SDs[i] = V_sdev		
	
	
	endfor
end

// quickdisplay
Function qd (letter, mousestring)
	string letter,mousestring

	setdatafolder root:data_records
	NewPath/O graphics "Macintosh HD:Users:nipadmin:Documents:SCIENCE:graphics" 
	
	WAVE HI_NIP1
	string referencename = replacestring("r",note(HI_NIP1),"",1,1)
	string labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " RAW"
	
	// unrereference all channels
	unreference ("HI_NIP", 16, referencename)

	// display all channels with full x-axis
	display HI_NIP1, HI_NIP2, HI_NIP3,  HI_NIP4, HI_NIP5, HI_NIP6, HI_NIP7, HI_NIP8, HI_NIP9, HI_NIP10, HI_NIP11, HI_NIP12, HI_NIP13, HI_NIP14, HI_NIP15, HI_NIP16
	appendtograph $referencename
	modifygraph rgb=(0,0,0)
	modifygraph rgb[16]=(65535,0,0)
	modifygraph lsize=0.5
	newlayout/P=landscape
	appendlayoutobject/R=(21,21,749,511)/F=0/T=1 graph graph0
	TextBox/C/N=text0/F=0/A=LB/X=8.47/Y=9.06 labelstring
	
	// offset all channels
	offsetgene (xoffset=0,yoffset=-40000)
	
	// save out graphics
	string currentexpname = replacestring("_HI_NIP", IgorInfo(1), "")
	string graphicname = letter+"_"+mousestring+"_"+currentexpname+"_RAWalltime.png"
	savepict/b=144/E=-5/P=graphics as graphicname

	
	// display all channels with a zoomed x-axis
	display HI_NIP1, HI_NIP2, HI_NIP3,  HI_NIP4, HI_NIP5, HI_NIP6, HI_NIP7, HI_NIP8, HI_NIP9, HI_NIP10, HI_NIP11, HI_NIP12, HI_NIP13, HI_NIP14, HI_NIP15, HI_NIP16
	appendtograph $referencename
	modifygraph rgb=(0,0,0)
	modifygraph rgb[16]=(65535,0,0)
	setaxis bottom 400000,410000
	modifygraph lsize=0.5
	newlayout/P=landscape
	appendlayoutobject/R=(21,21,749,511)/F=0/T=1 graph graph1	
	TextBox/C/N=text0/F=0/A=LB/X=8.47/Y=9.06 labelstring

	// offset all channels
	offsetgene (xoffset=0,yoffset=-20000)
	
	// save out graphics
	graphicname = letter+"_"+mousestring+"_"+currentexpname+"_RAW10sec.png"
	savepict/b=144/E=-5/P=graphics as graphicname
	

end

// quicksave
Function qs (letter, mousestring, refname)
	string letter,mousestring, refname
	
	setdatafolder root:data_records
	NewPath/O graphics "Macintosh HD:Users:nipadmin:Documents:SCIENCE:graphics" 

	string currentexpname = replacestring("_HI_NIP", IgorInfo(1), "")

	string labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + refname
	string graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + refname + "alltime.png"

	// bring up Layout0
	dowindow/f Layout0
	
	// change the textbox
	Textbox/C/N=text0 labelstring
		
	// save
	savepict/b=144/E=-5/P=graphics as graphicname
	
	// bring up Layout1
	dowindow/f Layout1
	graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + refname + "10sec.png"

	// change the textbox
	Textbox/C/N=text0 labelstring
		
	// save
	savepict/b=144/E=-5/P=graphics as graphicname

end

// quickdisplay
Function qds (letter, mousestring)
	string letter,mousestring

	setdatafolder root:data_records
	NewPath/O graphics "Macintosh HD:Users:nipadmin:Documents:SCIENCE:graphics" 
	string currentexpname = replacestring("_HI_NIP", IgorInfo(1), "")

	WAVE HI_NIP1
	string refname = replacestring("r",note(HI_NIP1),"",1,1)
	
	// first do displays of rereferenced since they are already computed
	
	string labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + refname
	
	// display all channels with full x-axis
	display HI_NIP1, HI_NIP2, HI_NIP3,  HI_NIP4, HI_NIP5, HI_NIP6, HI_NIP7, HI_NIP8, HI_NIP9, HI_NIP10, HI_NIP11, HI_NIP12, HI_NIP13, HI_NIP14, HI_NIP15, HI_NIP16
	appendtograph $refname
	modifygraph rgb=(0,0,0)
	modifygraph rgb[16]=(65535,0,0)
	modifygraph lsize=0.5
	
	// offset all channels
	offsetgene (xoffset=0,yoffset=-40000)
	
	// set up layout0	
	newlayout/P=landscape
	appendlayoutobject/R=(21,21,749,511)/F=0/T=1 graph graph0
	TextBox/C/N=text0/F=0/A=LB/X=8.47/Y=9.06 labelstring
	
	// save out graphics
	string graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + refname + "_alltime.png"
	savepict/b=144/E=-5/P=graphics as graphicname
	
	// display all channels with a zoomed x-axis
	display HI_NIP1, HI_NIP2, HI_NIP3,  HI_NIP4, HI_NIP5, HI_NIP6, HI_NIP7, HI_NIP8, HI_NIP9, HI_NIP10, HI_NIP11, HI_NIP12, HI_NIP13, HI_NIP14, HI_NIP15, HI_NIP16
	appendtograph $refname
	modifygraph rgb=(0,0,0)
	modifygraph rgb[16]=(65535,0,0)
	setaxis bottom 400000,410000
	modifygraph lsize=0.5

	// offset all channels
	offsetgene (xoffset=0,yoffset=-20000)
	
	// set up layout
	newlayout/P=landscape
	appendlayoutobject/R=(21,21,749,511)/F=0/T=1 graph graph1	
	TextBox/C/N=text0/F=0/A=LB/X=8.47/Y=9.06 labelstring

	// save out graphics
	graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + refname + "_10sec.png"
	savepict/b=144/E=-5/P=graphics as graphicname
		
	// unrereference all channels
	unreference ("HI_NIP", 16, refname)

	// bring up Layout0
	dowindow/f Layout0
	
	// change textbox
	labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + "RAW"
	Textbox/C/N=text0 labelstring

	// resave
	graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + "RAW_alltime.png"
	savepict/b=144/E=-5/P=graphics as graphicname
	
	// bring up Layout1
	dowindow/f Layout1
	
	// change textbox
	labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + "RAW"
	Textbox/C/N=text0 labelstring

	
	// resave
	graphicname = letter+"_"+mousestring+"_"+currentexpname+"_" + "RAW_10sec.png"
	savepict/b=144/E=-5/P=graphics as graphicname
	
	
	// put channels back the way I found them	
	rereference ("HI_NIP", 16, refname)
	
	// fix layout labels to be accurate after putting channels back
	dowindow/f Layout0
	labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + refname
	Textbox/C/N=text0 labelstring

	// fix layout labels to be accurate after putting channels back
	dowindow/f Layout1
	labelstring = mousestring + "   " + letter+  " "+igorinfo(1) + " " + refname
	Textbox/C/N=text0 labelstring
	
end

// move all waves matching matchstring into destinationdatafolder
Function movematching (matchstring, destinationdatafolder)
	string matchstring, destinationdatafolder

	string movelist = wavelist(matchstring, ";","")
	variable numwaves = itemsinlist (movelist),i
	
	for (i=0; i < numwaves; i += 1)
		
		WAVE nextwave = $(stringfromlist (i, movelist))
		movewave nextwave, $destinationdatafolder

	endfor
	
	printf "moved %d waves matching %s to %s\r", numwaves, matchstring, destinationdatafolder
	
end

// clean up channel names
// foldername must be within the current folder
Function cleanupchannelnames (foldername, matchstring)
	string foldername, matchstring

	if (!datafolderexists(foldername))
		abort "cleanupchannelnames aborted because folder doesn't exist"
	endif
	
	// go into the folder called foldername
	setdatafolder $foldername	

	string theWaves = wavelist("*"+matchstring+"*", ";",""), nextwaveoldname, nextwavenewname
	variable numwaves = itemsinlist(thewaves),i
	
	for (i=0; i < numwaves; i += 1)

		nextwaveoldname = StringFromList(i, theWaves)
		nextwavenewname = uptowhatever(nextwaveoldname,"_",searchfrontwards=0)
		
		rename $nextwaveoldname $nextwavenewname
	
	endfor
	
	setdatafolder ::
	
	
end

// multisave
// savewave is a two-column text wave that contains subdirectory and wavenames to save out.  then when we get to the bottom just iterate through it.

Function MultiSave (savewave)
	WAVE/T savewave


	// first check column 0 for any referenced folders that don't exist 
	// use newpath to create the folders if they don't exist?

	// then loop through, using save with a full path to the file


	// kill paths created, just to clean up?

end

// I think this should be able to reduce string lengths by about 66% which should be more than enough
Function/S base64shortener (longnumberasstring)
	string longnumberasstring
	
	variable numchars=strlen(longnumberasstring),i
	string result = ""

	// step along the long number
	
	for (i=0; i < numchars; i += 1)
			
		string nexttuple = longnumberasstring[i,i+1]
		variable nexttuple_asnum = str2num(nexttuple)

		//print nexttuple
		
		// have to handle case where tuple starts with a zero!!
		// not hard - zero in first position must always be handled as special case
		if (str2num(longnumberasstring[i]) == 0)
			result+= "A"		
		elseif (nexttuple_asnum <= 61)
			result += (base64indextochar(nexttuple_asnum))
			i += 1
		else
			result += base64indextochar(str2num(longnumberasstring[i]))
		endif
	
	endfor
	
	return result

end

// take a base64 string and expand it into a decimal string
Function/S base64expander (base64numberasstring)
	string base64numberasstring
	
	variable numchars = strlen(base64numberasstring), i
	string result = "", nextexpansion
	
	for (i=0; i < numchars; i += 1)
	
		nextexpansion = num2str(chartobase64index(base64numberasstring[i]))
		result += nextexpansion
	
	endfor
	
	return result

end

Function/s base64indextochar (index)
	variable index
	
	string resultchar
	
	if (index < 26)
		resultchar = num2char(index+65)
	elseif (index < 52)
		resultchar = num2char(index+71)
	else
		resultchar= num2str(index-52)
	endif
	
	return resultchar
	
end

Function chartobase64index (char)
	string char
	
	variable index
	
	variable ASCIInum = char2num(char)
	
	// uppercase range
	if ((ASCIInum >= 65) && (ASCIInum <= 90))
		index = ASCIInum - 65
	// lowercase range
	elseif ((ASCIInum >= 97) && (ASCIInum <= 122))
		index = ASCIInum - 71	
	// digits range
	elseif ((ASCIInum >= 48) && (ASCIInum <= 57))
		index = ASCIInum + 4	
	endif
	
	return index
	
end


// Functions to map analysis types to input-output types
Function AnalysisTakesSingleChannelInput (analysis)
	string analysis
	
	WAVE inputtype = root:neuromaven_resources:inputtype
	
	variable index = FindDimLabel(inputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (inputtype[index] == 0)
		return 1
	elseif (inputtype[index] == 1)
		return 0
	endif
end

Function AnalysisTakesMultiChannelInput (analysis)
	string analysis
	
	WAVE inputtype = root:neuromaven_resources:inputtype
	
	variable index = FindDimLabel(inputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (inputtype[index] == 0)
		return 0
	elseif (inputtype[index] == 1)
		return 1
	endif
end

Function AnalysisReturnsOneNumber (analysis)
	string analysis
	
	WAVE outputtype = root:neuromaven_resources:outputtype
	
	variable index = FindDimLabel(outputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (outputtype[index] == 0)
		return 1
	else
		return 0
	endif
end

Function AnalysisReturnsSingle1DVector (analysis)
	string analysis
	
	WAVE outputtype = root:neuromaven_resources:outputtype
	
	variable index = FindDimLabel(outputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (outputtype[index] == 1)
		return 1
	else
		return 0
	endif
end

Function AnalysisReturnsSingle2DVector (analysis)
	string analysis
	
	WAVE outputtype = root:neuromaven_resources:outputtype
	
	variable index = FindDimLabel(outputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (outputtype[index] == 2)
		return 1
	else
		return 0
	endif
end

Function AnalysisReturnsMultipleVectors (analysis)
	string analysis
	
	WAVE outputtype = root:neuromaven_resources:outputtype
	
	variable index = FindDimLabel(outputtype, 0, analysis)
	if (index == -2)
		printf "unknown analysis %s\r", analysis
		abort
	endif
	
	if (outputtype[index] == 3)
		return 1
	else
		return 0
	endif
end